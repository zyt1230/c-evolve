# 一、并发服务器的引入


<font style="color:rgb(51,51,51);">对于tcp通信方式而言，目前的通信方式，只能实现一个服务器端对应一个客户端，不能实现</font>**<font style="color:#DF2A3F;">一个服务 器对应多个客户端</font>**<font style="color:rgb(51,51,51);">，为了完成该操作，我们需要引入并发操作</font>

# 二、方法一：循环服务器（**<font style="color:rgb(64, 64, 64);">单线程阻塞模型</font>**）
## 1、<font style="color:rgb(51,51,51);">循环服务器的模型</font>
```cpp
sfd = socket();    //创建用于链接的套接字文件描述符
bind();             //绑定ip地址和端口号
listen();            //启动被动监听状态
while(1)
{
 newfd = accept();       //阻塞接受客户端连接请求
 
 //跟客户端进行数据收发
 recv();
 send();
 close(newfd);
}
close(sfd);
```

## 2、tcp服务加一个while
```cpp
#include<myhead.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netinet/in.h>
#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.102.142"//服务器ip地址
int main(int argc,const char* argv[])
{
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip
    sin.sin_port=htons(SER_PORT);//服务器端口号

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    int i =bind(sfd,(struct sockaddr*)&sin,sizeof(sin));
    if(i ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度
    while(1){
        int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
        //参数1：服务器套接字文件描述符
        //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
        //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
        if(newfd == -1){
            perror("accept error");
            return -1;
        }
        printf("[%s:%d]:已经连接成功！！！\n",
            inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
        
        //5、数据收发
        char rbuf[128]="";//数据容器
        while(1){
            //清空容器
            bzero(rbuf,sizeof(rbuf));
            //从套接字中读取消息
            int res = recv(newfd,rbuf,sizeof(rbuf),0);
            if(res ==0 ){
                printf("对端已经下线\n");
                break;
            }
            printf("[%s:%d]:%s\n",inet_ntoa(cin.sin_addr),ntohs(cin.sin_port),rbuf);
            //对收到的数据随便处理一下，回给客户端
            strcat(rbuf,"*_*");
            //将消息发送给客户端
            if(send(newfd,rbuf,strlen(rbuf)-1,0)==-1){
                perror("send error");
                return -1;
            }
            printf("发送成功\n");
        }
        
        close(newfd);
    }
    //6、关闭套接字
    
    close(sfd);
    cout<<"hello world"<<endl;
    return 0;
}

```

## 3、注意点【第2个客户发出的数据没有打印出来的重点原因】
<font style="color:rgb(64, 64, 64);">当服务器在内层</font>`**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">while</font>**`<font style="color:rgb(64, 64, 64);">循环中调用</font>`**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">recv()</font>**`<font style="color:rgb(64, 64, 64);">时，会</font>**<font style="color:#DF2A3F;">一直阻塞等待该客户端发送数据，导致无法处理其他客户端的连接请求</font>**<font style="color:rgb(64, 64, 64);">。这就是为什么第二个客户端无法正常工作的原因。</font>

<font style="color:rgb(64, 64, 64);">例如：</font>

+ <font style="color:rgb(64, 64, 64);">客人A坐下后，服务员就一直站在他桌子旁边</font>
+ <font style="color:rgb(64, 64, 64);">即使客人A暂时不点菜（不发送数据），服务员也一直等着</font>
+ <font style="color:rgb(64, 64, 64);">此时其他客人（客户端B、C等）虽然进了餐馆，但没人接待</font>

# 三、多进程实现并发服务器
## 1、定义和模型
+ <font style="color:#DF2A3F;">主进程</font><font style="color:rgb(51,51,51);">可以用于完成</font><font style="color:#DF2A3F;">对客户端的连接请求</font><font style="color:rgb(51,51,51);">，</font><font style="color:#DF2A3F;">子进程</font><font style="color:rgb(51,51,51);">可以完成</font><font style="color:#DF2A3F;">对客户端通信操作</font><font style="color:rgb(51,51,51);">。</font>

```cpp
void handler(int signo)
{
     while(waitpid() > 0);       //以非阻塞形式回收僵尸进程
}

signal(SIGCHLD, handler);        //将信号与信号处理函数连接起来
sfd = socket();    //创建用于链接的套接字文件描述符
bind();             //绑定ip地址和端口号
listen();            //启动被动监听状态
while(1)
{
     newfd = accept();       //阻塞接受客户端连接请求
     pid = fork();     //创建子进程用于跟客户端进行通信
     if(pid > 0)
     {
         //关闭newfd
         close(newfd);
     }else if(pid == 0)
     {
         //子进程
         close(sfd);
         //跟客户端进行数据收发
         recv();
         send();
         close(newfd);
            
         exit(EXIT_SUCCESS);    //退出子进程
     }
 
}
close(sfd);
```

## 2、实现
```cpp
#include<myhead.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netinet/in.h>
#include<signal.h>
#include<sys/wait.h>
#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.102.142"//服务器ip地址

//自定义信号处理函数------------------------------------------
void handler(int signo){
    //将子进程发送的SIGCHLD信号连接到自定义信号处理函数中
    if(signo==SIGCHLD){
        while(waitpid(-1,NULL,WNOHANG)>0);
    }
}

int main(int argc,const char* argv[])
{
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip
    sin.sin_port=htons(SER_PORT);//服务器端口号

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    int i =bind(sfd,(struct sockaddr*)&sin,sizeof(sin));
    if(i ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度
    while(1){
        int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
        //参数1：服务器套接字文件描述符
        //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
        //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
        if(newfd == -1){
            perror("accept error");
            return -1;
        }
        printf("[%s:%d]:已经连接成功！！！\n",
            inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
        pid_t pid = fork();//创建子进程-----------------------------
        if(pid>0){
            //父进程内容
            //wait(NULL);     //?   不可以使用wait，因为该函数时阻塞函数
    //waitpid(-1, NULL, WNOHANG);   //以非阻塞形式回收？
    //关闭newfd因为，父进程不对newfd进行操作
            close(newfd);
        }else if(pid==0){
            //关闭sfd，因为子进程主要专注于跟客户端的通信，主要使用newfd
            close(sfd);
            //5、数据收发
            char rbuf[128]="";//数据容器
            while(1){
                //清空容器
                bzero(rbuf,sizeof(rbuf));
                //从套接字中读取消息
                int res = recv(newfd,rbuf,sizeof(rbuf),0);
                if(res ==0 ){
                    printf("对端已经下线\n");
                    break;
                }
                printf("[%s:%d]:%s\n",inet_ntoa(cin.sin_addr),ntohs(cin.sin_port),rbuf);
                //对收到的数据随便处理一下，回给客户端
                strcat(rbuf,"*_*");
                //将消息发送给客户端
                if(send(newfd,rbuf,strlen(rbuf)-1,0)==-1){
                    perror("send error");
                    return -1;
                }
                printf("发送成功\n");
            }
            //关闭套接字
            close(newfd);
            //退出子进程
            exit(EXIT_SUCCESS);
        }else{
            perror("fork error");
            return -1;
        }
    }
    
    close(sfd);//关闭监听
    cout<<"hello world"<<endl;
    return 0;
}

```

## 3、注意
+ `**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">wait()</font>**`<font style="color:rgb(64, 64, 64);"> 是</font>**<font style="color:rgb(64, 64, 64);">阻塞函数</font>**<font style="color:rgb(64, 64, 64);">，会一直等待直到有子进程退出</font>
+ `**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">waitpid</font>**`<font style="color:rgb(64, 64, 64);"> 配合 </font>`**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">WNOHANG</font>**`<font style="color:rgb(64, 64, 64);"> 选项可以非阻塞地检查子进程状态</font>
    - <font style="color:rgb(64, 64, 64);">但是也不能用。</font>**<font style="color:#DF2A3F;">子进程退出时，信号处理函数已经调用了 </font>**`**<font style="color:#DF2A3F;background-color:rgb(236, 236, 236);">waitpid</font>**`**<font style="color:#DF2A3F;">，主循环再次调用可能返回 </font>**`**<font style="color:#DF2A3F;background-color:rgb(236, 236, 236);">-1</font>**`**<font style="color:#DF2A3F;">（无子进程），导致不必要的系统调用</font>**<font style="color:rgb(64, 64, 64);">。</font>
    - <font style="color:rgb(64, 64, 64);">所以使用SIGCHLD信号连接到自定义处理函数中。</font>**<font style="color:#DF2A3F;">优化</font>**<font style="color:rgb(64, 64, 64);">。</font>

# 四、多线程实现并发服务器
## 1、定义和模型
+ <font style="color:rgb(51,51,51);">主线程用于接收</font>**<font style="color:#DF2A3F;">客户端的连接请求</font>**<font style="color:rgb(51,51,51);">，分支线程用于跟</font>**<font style="color:#DF2A3F;">客户端进行通信</font>**<font style="color:rgb(51,51,51);">。</font>

```cpp
//定义分支线程
void *deal_cli_msg(void *arg)
{
//跟客户端进行数据收发
 recv();
 send();
 close(newfd);
 //退出线程
 pthread_exit(NULL);
}
//主线程内容
sfd = socket();    //创建用于链接的套接字文件描述符
bind();             //绑定ip地址和端口号
listen();            //启动被动监听状态
while(1)
{
 newfd = accept();       //阻塞接受客户端连接请求
 
 pthread_create(&tid, NULL, deal_cli_msg, &buf);    //创建分支线程
 
 //将线程设置成分离态
 pthread_detach(tid);
 
 
}
close(sfd);
```

## 2、实现
```cpp
#include<myhead.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netinet/in.h>
#include<signal.h>
#include<sys/wait.h>
#include<pthread.h>
#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.102.142"//服务器ip地址
//定义用于传递数据的结构体类型
struct Info{
    int newfd;//套接字文件描述符
    struct sockaddr_in cin;//客户端套接字地址信息结构体
};
//分支线程，用户跟客户端进行通信
void *deal_cli_msg(void* arg){
    //解析传过来的数据
    int newfd = ((struct Info*)arg)->newfd;//解析套接字文件描述符
    struct sockaddr_in cin=((struct Info*)arg)->cin;
    char rbuf[128]="";//数据容器
    while(1){
        //清空容器中的内容
        bzero(rbuf,sizeof(rbuf));
        //从套接字中读取消息
        int res = recv(newfd,rbuf,sizeof(rbuf),0);
        if(res==0){
            printf("对端已经下线\n");
            break;
        }
        printf("[%s:%d]:%s\n",inet_ntoa(cin.sin_addr),ntohs(cin.sin_port), rbuf);
        //对收到的数据处理一下，回给客户端
        strcat(rbuf, "*_*");
        //将消息发送给客户端
        if(send(newfd, rbuf, strlen(rbuf), 0) == -1){
            perror("send error");
            return NULL;
        }
        printf("发送成功\n");
    }
    //关闭套接字
    close(newfd);
    //退出分支线程
    pthread_exit(NULL);
}

int main(int argc,const char* argv[])
{
    
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip
    sin.sin_port=htons(SER_PORT);//服务器端口号

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    int i =bind(sfd,(struct sockaddr*)&sin,sizeof(sin));
    if(i ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度
    while(1){
        int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
        //参数1：服务器套接字文件描述符
        //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
        //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
        if(newfd == -1){
            perror("accept error");
            return -1;
        }
        printf("[%s:%d]:已经连接成功！！！\n",
            inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
        //创建分支线程，用于处理客户端的操作-----------------------------
        struct Info buf = {newfd,cin};
        
        pthread_t tid=-1;
        if(pthread_create(&tid,NULL,deal_cli_msg,&buf)!=0)
        {
            printf("pthread_create error\n");
            return -1;
        }
        //pthread_join(tid,NULL);//?不能使用这个函数回收，因为该函数会阻塞
        pthread_detach(tid);//将线程设置成分离态，执行结束后，系统自动回收资源
    }
    
    close(sfd);//关闭监听
    cout<<"hello world"<<endl;
    return 0;
}
           
```

# 五、IO多路复用
## 1、了解函数和事件
+ IO多路复用引入目的：
    - <font style="color:rgb(51,51,51);">当主机</font>**<font style="color:#DF2A3F;">没有操作系统</font>**<font style="color:rgb(51,51,51);">时，或者说程序</font>**<font style="color:rgb(51,51,51);">不能使用多进程或多线程完成任务的并发操作时， 我们可以引入IO多路复用的技术</font>**<font style="color:rgb(51,51,51);">，完成多任务并发执行的操作。</font>
+ <font style="color:rgb(51,51,51);">事件和函数的关系：比如，scanf是一个阻塞函数，该函数完成的是输入事件</font>
    - <font style="color:rgb(51,51,51);">当函数先于事件发生时，函数会阻塞等待事件的到来</font>
    - <font style="color:rgb(51,51,51);">当函数后于事件发生时，函数就不会阻塞，直接执行</font>

```cpp
#include<myhead.h>
int main(int argc,const char* argv[])
{
    int num=0;
    int key;
    printf("请输入的值：");
    scanf("%d",&num);
    printf("num=%d\n",num);

    printf("请输入key的值：");
    scanf("%d",&key);
    printf("key=%d\n",key);
    return 0;
}
```

+ 使用直接输入1 2 的方式

![](https://cdn.nlark.com/yuque/0/2025/png/40383045/1746026467974-ba0b2a71-ad24-4c7e-a828-a635ca51a20d.png)

+ 使用先输入1，再输入2的方式

![](https://cdn.nlark.com/yuque/0/2025/png/40383045/1746026512669-2a6dbab7-0635-4936-a043-5f9eb5b13c40.png)

<font style="color:rgb(51,51,51);">从上述例子中的</font>**<font style="color:#DF2A3F;">第二个输入可以看出，如果事件先于函数发生，当程序再执行到函数时，函数会直接运 行，不会阻塞了</font>**<font style="color:rgb(51,51,51);"> 。</font>

## 2、IO多路复用原理图
![](https://cdn.nlark.com/yuque/0/2025/png/40383045/1746106460960-71e7c5b5-ed0b-4da6-98e6-d18ff7e9adcb.png)

## 3、select函数
### 3.1、select的了解和模型
+ 注意：**<font style="color:#DF2A3F;">当该函数解除阻塞时，文件描述符集合中，就只剩下本次触发事件的文件描述符，其余的文</font>**

**<font style="color:#DF2A3F;">件描述符就被删除了</font>** 。

```cpp
       #include <sys/select.h>
       int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, 
struct timeval *timeout);
       功能：阻塞等待文件描述符集合中是否有事件产生，如果有事件产生，则解除阻塞
       参数1：文件描述符集合中，最大的文件描述符 加1
                  参数2、参数3、参数4：分别表示读集合、写集合、异常处理集合的起始地址
       由于对于写操作而言，我们也可以转换读操作，所以，只需要使用一个集合
就行
       对于不使用的集合而言，直接填NULL即可
       参数5：超时时间，如果填NULL表示永久等待，如果想要设置时间，需要定义一个如下结构体类型
的变量，并将地址传递进去
       struct timeval {
               long    tv_sec;         /* 秒数 */
               long    tv_usec;        /* 微秒 */
           };
       and
           struct timespec {
               long    tv_sec;         /* 秒数 */
               long    tv_nsec;        /* 纳秒 */
           };
       返回值：
       >0:成功返回解除本次阻塞的文件描述符的个数
       =0:表示设置的超时时间，时间已经到达，但是没有事件事件产生
       =-1：表示失败，置位错误码
       注意：当该函数解除阻塞时，文件描述符集合中，就只剩下本次触发事件的文件描述符，其余的文
件描述符就被删除了
       
//专门针对于文件描述符集合提供的函数
       void FD_CLR(int fd, fd_set *set);       //将fd文件描述符从容器set中删除
       int  FD_ISSET(int fd, fd_set *set);     //判断fd文件描述符，是否存在于set容器
中
       void FD_SET(int fd, fd_set *set);      //将fd文件描述符，放入到set容器中
       void FD_ZERO(fd_set *set); //清空set容器
```

```cpp
sfd = socket();        //创建用于连接的套接字文件描述符
bind();                //绑定ip和端口号
listen();               //监听
fd_set  readfds, tempfds;    //定义文件描述符集合
FD_ZERO();        //清空容器
FD_SET();         //将文件描述符放入容器
maxfd = sfd;         //记录最大的文件描述符
while(1)
{
 tempfds = readfds;      //备份一份容器
 select(maxfd, &readfds, NULL, NULL, NULL);     //阻塞等待集合中是否有事件产生
 
 //判断相关文件描述符是否在集合中
 if(FD_ISSET(sfd, &tempfds))
 {
 newfd = accept();      //接收客户端请求
 FD_SET(newfd, &readfds);    //将新文件描述符放入集合
 //更新maxfd
 }
 
 //判断是否是客户端发来数据
 for(i=4; i<=maxfd; i++)
 {
 send();
 recv();
 close(i);     //退出客户端
 FD_CLR(i, &readfds);
 //更新maxfd
 }
 
}
//关闭监听
close(sfd);
```

### 3.2、实现select并发
```cpp
#include<myhead.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netinet/in.h>
#include<signal.h>
#include<sys/wait.h>
#include<pthread.h>
#include<sys/select.h>
#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.140.142"//服务器ip地址

int main(int argc,const char* argv[])
{
    
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    if(sfd==-1){
        perror("socket error");
        return -1;
    }
    printf("socket success sfd = %d\n",sfd);//3
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip
    sin.sin_port=htons(SER_PORT);//服务器端口号

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    int i =bind(sfd,(struct sockaddr*)&sin,sizeof(sin));
    if(i ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度
    
    //定义文件描述符集合
    fd_set readfds,tempfds;//读文件描述符集合
    //将该文件描述符清空
    FD_ZERO(&readfds);
    //将0号文件描述符以及sfd文件描述符放入到集合中
    FD_SET(0,&readfds);
    FD_SET(sfd,&readfds);//sfd是socket创建的
    
    //定义一个变量，用于存储容器中的最大文件描述符
    int maxfd = sfd;
    int newfd = -1;//接收客户端连接请求后，创建的通信套接字文件描述符
    //定义一个地址信息结构体数组来存储客户端对应的地址信息
    struct sockaddr_in cin_arr[1024];
    while(1){
        //将readfds备份放入tempfds中
        tempfds = readfds;
        //调用阻塞函数，完成对文件描述符集合的管理工作
        int res = select(maxfd+1,&tempfds,NULL,NULL,NULL);
        if(res == -1){
            perror("select error");
            return -1;
        }else if(res == 0){
            printf("time out!!!\n");
            return -1;
        }
        /*
        程序执行到此，表示一定有其中至少一个文件描述符产生了事件，
        只需要判断哪个文件描述符还在集合中
        */
        
        //就说明该文件描述符产生了事件
        //表示sfd文件描述符触发了事件,准备就绪，开始处理
        if(FD_ISSET(sfd,&tempfds)){
            int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
            //参数1：服务器套接字文件描述符
            //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
            //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
            if(newfd == -1){
                perror("accept error");
                return -1;
            }
            printf("[%s:%d]:已经连接成功！！！\n",
                inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
            //将该客户端对应的套接字地址信息结构体放入数组对应的位置上
            cin_arr[newfd]=cin;//newfd文件描述符对应的地址信息结构体
            //将当前的newfd放入到检测文件描述符集合中，以便于检测使用
            FD_SET(newfd,&readfds);//加入到tempfds
            //更新maxfd，如何更新？
            if(maxfd<newfd)//更新最大文件描述符
            {
                maxfd = newfd;
            }
        }
        //判断0号文件描述符是否产生了事件
        if(FD_ISSET(0,&tempfds)){
            char wbuf[128]="";//字符数组
            fgets(wbuf,sizeof(wbuf),stdin);//从终端读取数据，阻塞函数
            printf("触发了将输入输入事件：%s\n",wbuf);
            //能不能将输入的数据，全部发送给所有客户端

            for(int i =4;i<=maxfd;i++){
                send(i,wbuf,strlen(wbuf),0);//将数据发送给所有客户端
            }
        }
        //判断是否是newfd产生了事件
        /*循环所有客户端文件描述符遍历一遍，如果还存在于tempfds中的客户端，
        表示有数据接收过来*/
        for(int i = 4;i<=maxfd;i++){
            if(FD_ISSET(i,&tempfds))
            {
                //5、数据收发
                char rbuf[128]="";//数据容器
                //清空容器中的的内容
                bzero(rbuf,sizeof(rbuf));
                //从套接字中读取消息
                int res = recv(i,rbuf,sizeof(rbuf),0);
                if(res==0){
                    printf("对端已经下线\n");
                    close(i);
                    FD_CLR(i,&readfds);
                    //更新maxfd
                    for(int k = maxfd;k>=0;k--){
                        if(FD_ISSET(k,&readfds)){
                            maxfd = k;
                            break;//结束向下进行的循环
                        }
                    }
                    continue;
                }
                printf("[%s:%d]:%s\n",inet_ntoa(cin_arr[i].sin_addr),ntohs(cin_arr[i].sin_port),rbuf);
                //将处理后的客户端消息回显给该客户端
                strcat(rbuf,"*_*");
                if(send(i,rbuf,strlen(rbuf),0)==-1){
                    perror("send error");
                    return -1;
                }
                printf("发送成功!\n");
            }
        }
    }
    close(sfd);//关闭监听
    cout<<"hello world"<<endl;
    return 0;
}
           
```

## 4、poll函数
### 4.1、poll的了解和模型
```cpp
       #include <poll.h>
       int poll(struct pollfd *fds, nfds_t nfds, int timeout);
       功能：阻塞等待文件描述符集合中是否有事件产生，如果有，则解除阻塞，返回本次触发事件的文件
描述符个数
       参数1：文件描述符集合容器的起始地址，是一个结构体数组，结构体类型如下
       struct pollfd {
               int   fd;         /* 文件描述符 */
               short events;     /* 要等待的事件：由用户填写 */
               short revents;    /* 实际发生的事件 ：调用函数结束后，内核会自动设置*/
           };
           关于事件对应的位：
           POLLIN:读事件
           POLLOUT：写事件
           
       参数2：集合中文件描述符的个数
       参数3：超时时间，负数表示永久等待，0表示非阻塞
       返回值：
       >0:表示触发本次解除阻塞事件的文件描述符的个数
       =0:表示超时
       =-1:出错，置位错误码
```

### 4.2、实现poll并发
```cpp

```

## 5、select和poll的差异
+ 1、select管理三个文件描述符集合，poll只管理一个，但是，<font style="color:#DF2A3F;">可以操作很多事件</font>
+ 2、select管理的文件描述符有上限，<font style="color:#DF2A3F;">一般是1024个</font>，而<font style="color:#DF2A3F;">poll管理文件描述符没有这个限制</font>
+ 3、对于效率而言，<font style="color:#DF2A3F;">poll的效率比select的略高</font>

## 6、epoll函数
### 6.1、epoll的了解和模型
```cpp

```

### 6.2、实现epoll并发
```cpp

```

## 7、epoll、select、poll的差异
+ <font style="color:rgb(17,102,68);">1</font><font style="color:rgb(0,0,0);">、</font><font style="color:#DF2A3F;">sellect和poll都是基于线性结构</font><font style="color:rgb(0,0,0);">进行检测集合，而</font><font style="color:#DF2A3F;">epoll是基于树形结构（红黑树）完成管理检测集合 </font><font style="color:rgb(0,0,0);">的 </font>
+ <font style="color:rgb(17,102,68);">2</font><font style="color:rgb(0,0,0);">、select和poll检测时，</font><font style="color:#DF2A3F;">随着集合的增大，效率会越来越低</font><font style="color:rgb(0,0,0);">。epoll使用的是函数回调机制，效率较高。 </font><font style="color:#DF2A3F;">处理文件描述符的效率也不会随着文件秒数的增大而降低</font><font style="color:rgb(0,0,0);">。 </font>
+ <font style="color:rgb(17,102,68);">3</font><font style="color:rgb(0,0,0);">、select和poll在工作过程中，</font>**<font style="color:#DF2A3F;">不断的在内核空间与用户空间频繁拷贝文件描述符的数据</font>**<font style="color:rgb(0,0,0);">。epoll在注册 </font><font style="color:#DF2A3F;">新的文件描述符或者修改文件描述符</font><font style="color:rgb(0,0,0);">时，</font>**<font style="color:#DF2A3F;">只需进行一次，能够有效减少数据在用户空间和内核空间之间的切换 </font>**
+ <font style="color:rgb(17,102,68);">4</font><font style="color:rgb(0,0,0);">、和poll一样，</font><font style="color:#DF2A3F;">epoll没有最大文件描述符的限制</font><font style="color:rgb(0,0,0);">，仅仅收到程序能够打开的最大文件描述符数量限制 </font>
+ <font style="color:rgb(17,102,68);">5</font><font style="color:rgb(0,0,0);">、对于select和poll而言，需要对返回的文件描述符集合进行判断后才知道时哪些文件描述符就绪了，而 epoll可以直接得到已经就绪的文件描述符，</font>**<font style="color:#DF2A3F;">无需再次检测</font>**<font style="color:rgb(0,0,0);"> </font>
+ <font style="color:rgb(17,102,68);">6</font><font style="color:rgb(0,0,0);">、当多路复用</font><font style="color:#DF2A3F;">比较频发进行、IO流量频繁的时候</font><font style="color:rgb(0,0,0);">，一般不使用select和poll，</font>**<font style="color:#DF2A3F;">使用epoll</font>**<font style="color:rgb(0,0,0);">比较合适 </font>
+ <font style="color:rgb(17,102,68);">7</font><font style="color:rgb(0,0,0);">、</font><font style="color:#DF2A3F;">epoll只适用于linux平台</font><font style="color:rgb(0,0,0);">，不能跨平台操作</font>

