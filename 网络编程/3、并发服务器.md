# 一、并发服务器的引入


<font style="color:rgb(51,51,51);">对于tcp通信方式而言，目前的通信方式，只能实现一个服务器端对应一个客户端，不能实现</font>**<font style="color:#DF2A3F;">一个服务 器对应多个客户端</font>**<font style="color:rgb(51,51,51);">，为了完成该操作，我们需要引入并发操作</font>

# 二、方法一：循环服务器（**<font style="color:rgb(64, 64, 64);">单线程阻塞模型</font>**）
## 1、<font style="color:rgb(51,51,51);">循环服务器的模型</font>
```cpp
sfd = socket();    //创建用于链接的套接字文件描述符
bind();             //绑定ip地址和端口号
listen();            //启动被动监听状态
while(1)
{
 newfd = accept();       //阻塞接受客户端连接请求
 
 //跟客户端进行数据收发
 recv();
 send();
 close(newfd);
}
close(sfd);
```

## 2、tcp服务加一个while
```cpp
#include<myhead.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netinet/in.h>
#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.102.142"//服务器ip地址
int main(int argc,const char* argv[])
{
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip
    sin.sin_port=htons(SER_PORT);//服务器端口号

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    int i =bind(sfd,(struct sockaddr*)&sin,sizeof(sin));
    if(i ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度
    while(1){
        int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
        //参数1：服务器套接字文件描述符
        //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
        //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
        if(newfd == -1){
            perror("accept error");
            return -1;
        }
        printf("[%s:%d]:已经连接成功！！！\n",
            inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
        
        //5、数据收发
        char rbuf[128]="";//数据容器
        while(1){
            //清空容器
            bzero(rbuf,sizeof(rbuf));
            //从套接字中读取消息
            int res = recv(newfd,rbuf,sizeof(rbuf),0);
            if(res ==0 ){
                printf("对端已经下线\n");
                break;
            }
            printf("[%s:%d]:%s\n",inet_ntoa(cin.sin_addr),ntohs(cin.sin_port),rbuf);
            //对收到的数据随便处理一下，回给客户端
            strcat(rbuf,"*_*");
            //将消息发送给客户端
            if(send(newfd,rbuf,strlen(rbuf)-1,0)==-1){
                perror("send error");
                return -1;
            }
            printf("发送成功\n");
        }
        
        close(newfd);
    }
    //6、关闭套接字
    
    close(sfd);
    cout<<"hello world"<<endl;
    return 0;
}

```

## 3、注意点【第2个客户发出的数据没有打印出来的重点原因】
<font style="color:rgb(64, 64, 64);">当服务器在内层</font>`**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">while</font>**`<font style="color:rgb(64, 64, 64);">循环中调用</font>`**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">recv()</font>**`<font style="color:rgb(64, 64, 64);">时，会</font>**<font style="color:#DF2A3F;">一直阻塞等待该客户端发送数据，导致无法处理其他客户端的连接请求</font>**<font style="color:rgb(64, 64, 64);">。这就是为什么第二个客户端无法正常工作的原因。</font>

<font style="color:rgb(64, 64, 64);">例如：</font>

+ <font style="color:rgb(64, 64, 64);">客人A坐下后，服务员就一直站在他桌子旁边</font>
+ <font style="color:rgb(64, 64, 64);">即使客人A暂时不点菜（不发送数据），服务员也一直等着</font>
+ <font style="color:rgb(64, 64, 64);">此时其他客人（客户端B、C等）虽然进了餐馆，但没人接待</font>

# 三、多进程实现并发服务器
## 1、定义和模型
+ <font style="color:#DF2A3F;">主进程</font><font style="color:rgb(51,51,51);">可以用于完成</font><font style="color:#DF2A3F;">对客户端的连接请求</font><font style="color:rgb(51,51,51);">，</font><font style="color:#DF2A3F;">子进程</font><font style="color:rgb(51,51,51);">可以完成</font><font style="color:#DF2A3F;">对客户端通信操作</font><font style="color:rgb(51,51,51);">。</font>

```cpp
void handler(int signo)
{
     while(waitpid() > 0);       //以非阻塞形式回收僵尸进程
}

signal(SIGCHLD, handler);        //将信号与信号处理函数连接起来
sfd = socket();    //创建用于链接的套接字文件描述符
bind();             //绑定ip地址和端口号
listen();            //启动被动监听状态
while(1)
{
     newfd = accept();       //阻塞接受客户端连接请求
     pid = fork();     //创建子进程用于跟客户端进行通信
     if(pid > 0)
     {
         //关闭newfd
         close(newfd);
     }else if(pid == 0)
     {
         //子进程
         close(sfd);
         //跟客户端进行数据收发
         recv();
         send();
         close(newfd);
            
         exit(EXIT_SUCCESS);    //退出子进程
     }
 
}
close(sfd);
```

## 2、实现
```cpp
#include<myhead.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netinet/in.h>
#include<signal.h>
#include<sys/wait.h>
#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.102.142"//服务器ip地址

//自定义信号处理函数------------------------------------------
void handler(int signo){
    //将子进程发送的SIGCHLD信号连接到自定义信号处理函数中
    if(signo==SIGCHLD){
        while(waitpid(-1,NULL,WNOHANG)>0);
    }
}

int main(int argc,const char* argv[])
{
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip
    sin.sin_port=htons(SER_PORT);//服务器端口号

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    int i =bind(sfd,(struct sockaddr*)&sin,sizeof(sin));
    if(i ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度
    while(1){
        int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
        //参数1：服务器套接字文件描述符
        //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
        //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
        if(newfd == -1){
            perror("accept error");
            return -1;
        }
        printf("[%s:%d]:已经连接成功！！！\n",
            inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
        pid_t pid = fork();//创建子进程-----------------------------
        if(pid>0){
            //父进程内容
            //wait(NULL);     //?   不可以使用wait，因为该函数时阻塞函数
    //waitpid(-1, NULL, WNOHANG);   //以非阻塞形式回收？
    //关闭newfd因为，父进程不对newfd进行操作
            close(newfd);
        }else if(pid==0){
            //关闭sfd，因为子进程主要专注于跟客户端的通信，主要使用newfd
            close(sfd);
            //5、数据收发
            char rbuf[128]="";//数据容器
            while(1){
                //清空容器
                bzero(rbuf,sizeof(rbuf));
                //从套接字中读取消息
                int res = recv(newfd,rbuf,sizeof(rbuf),0);
                if(res ==0 ){
                    printf("对端已经下线\n");
                    break;
                }
                printf("[%s:%d]:%s\n",inet_ntoa(cin.sin_addr),ntohs(cin.sin_port),rbuf);
                //对收到的数据随便处理一下，回给客户端
                strcat(rbuf,"*_*");
                //将消息发送给客户端
                if(send(newfd,rbuf,strlen(rbuf)-1,0)==-1){
                    perror("send error");
                    return -1;
                }
                printf("发送成功\n");
            }
            //关闭套接字
            close(newfd);
            //退出子进程
            exit(EXIT_SUCCESS);
        }else{
            perror("fork error");
            return -1;
        }
    }
    
    close(sfd);//关闭监听
    cout<<"hello world"<<endl;
    return 0;
}

```

## 3、注意
+ `**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">wait()</font>**`<font style="color:rgb(64, 64, 64);"> 是</font>**<font style="color:rgb(64, 64, 64);">阻塞函数</font>**<font style="color:rgb(64, 64, 64);">，会一直等待直到有子进程退出</font>
+ `**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">waitpid</font>**`<font style="color:rgb(64, 64, 64);"> 配合 </font>`**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">WNOHANG</font>**`<font style="color:rgb(64, 64, 64);"> 选项可以非阻塞地检查子进程状态</font>
    - <font style="color:rgb(64, 64, 64);">但是也不能用。</font>**<font style="color:#DF2A3F;">子进程退出时，信号处理函数已经调用了 </font>**`**<font style="color:#DF2A3F;background-color:rgb(236, 236, 236);">waitpid</font>**`**<font style="color:#DF2A3F;">，主循环再次调用可能返回 </font>**`**<font style="color:#DF2A3F;background-color:rgb(236, 236, 236);">-1</font>**`**<font style="color:#DF2A3F;">（无子进程），导致不必要的系统调用</font>**<font style="color:rgb(64, 64, 64);">。</font>
    - <font style="color:rgb(64, 64, 64);">所以使用SIGCHLD信号连接到自定义处理函数中。</font>**<font style="color:#DF2A3F;">优化</font>**<font style="color:rgb(64, 64, 64);">。</font>

# 四、多线程实现并发服务器
## 1、定义和模型
+ <font style="color:rgb(51,51,51);">主线程用于接收</font>**<font style="color:#DF2A3F;">客户端的连接请求</font>**<font style="color:rgb(51,51,51);">，分支线程用于跟</font>**<font style="color:#DF2A3F;">客户端进行通信</font>**<font style="color:rgb(51,51,51);">。</font>

```cpp
//定义分支线程
void *deal_cli_msg(void *arg)
{
//跟客户端进行数据收发
 recv();
 send();
 close(newfd);
 //退出线程
 pthread_exit(NULL);
}
//主线程内容
sfd = socket();    //创建用于链接的套接字文件描述符
bind();             //绑定ip地址和端口号
listen();            //启动被动监听状态
while(1)
{
 newfd = accept();       //阻塞接受客户端连接请求
 
 pthread_create(&tid, NULL, deal_cli_msg, &buf);    //创建分支线程
 
 //将线程设置成分离态
 pthread_detach(tid);
 
 
}
close(sfd);
```

## 2、实现
```cpp
#include<myhead.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netinet/in.h>
#include<signal.h>
#include<sys/wait.h>
#include<pthread.h>
#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.102.142"//服务器ip地址
//定义用于传递数据的结构体类型
struct Info{
    int newfd;//套接字文件描述符
    struct sockaddr_in cin;//客户端套接字地址信息结构体
};
//分支线程，用户跟客户端进行通信
void *deal_cli_msg(void* arg){
    //解析传过来的数据
    int newfd = ((struct Info*)arg)->newfd;//解析套接字文件描述符
    struct sockaddr_in cin=((struct Info*)arg)->cin;
    char rbuf[128]="";//数据容器
    while(1){
        //清空容器中的内容
        bzero(rbuf,sizeof(rbuf));
        //从套接字中读取消息
        int res = recv(newfd,rbuf,sizeof(rbuf),0);
        if(res==0){
            printf("对端已经下线\n");
            break;
        }
        printf("[%s:%d]:%s\n",inet_ntoa(cin.sin_addr),ntohs(cin.sin_port), rbuf);
        //对收到的数据处理一下，回给客户端
        strcat(rbuf, "*_*");
        //将消息发送给客户端
        if(send(newfd, rbuf, strlen(rbuf), 0) == -1){
            perror("send error");
            return NULL;
        }
        printf("发送成功\n");
    }
    //关闭套接字
    close(newfd);
    //退出分支线程
    pthread_exit(NULL);
}

int main(int argc,const char* argv[])
{
    
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip
    sin.sin_port=htons(SER_PORT);//服务器端口号

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    int i =bind(sfd,(struct sockaddr*)&sin,sizeof(sin));
    if(i ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度
    while(1){
        int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
        //参数1：服务器套接字文件描述符
        //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
        //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
        if(newfd == -1){
            perror("accept error");
            return -1;
        }
        printf("[%s:%d]:已经连接成功！！！\n",
            inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
        //创建分支线程，用于处理客户端的操作-----------------------------
        struct Info buf = {newfd,cin};
        
        pthread_t tid=-1;
        if(pthread_create(&tid,NULL,deal_cli_msg,&buf)!=0)
        {
            printf("pthread_create error\n");
            return -1;
        }
        //pthread_join(tid,NULL);//?不能使用这个函数回收，因为该函数会阻塞
        pthread_detach(tid);//将线程设置成分离态，执行结束后，系统自动回收资源
    }
    
    close(sfd);//关闭监听
    cout<<"hello world"<<endl;
    return 0;
}
           
```

# 五、IO多路复用
## 1、了解函数和事件
+ IO多路复用引入目的：
    - <font style="color:rgb(51,51,51);">当主机</font>**<font style="color:#DF2A3F;">没有操作系统</font>**<font style="color:rgb(51,51,51);">时，或者说程序</font>**<font style="color:rgb(51,51,51);">不能使用多进程或多线程完成任务的并发操作时， 我们可以引入IO多路复用的技术</font>**<font style="color:rgb(51,51,51);">，完成多任务并发执行的操作。</font>
+ <font style="color:rgb(51,51,51);">事件和函数的关系：比如，scanf是一个阻塞函数，该函数完成的是输入事件</font>
    - <font style="color:rgb(51,51,51);">当函数先于事件发生时，函数会阻塞等待事件的到来</font>
    - <font style="color:rgb(51,51,51);">当函数后于事件发生时，函数就不会阻塞，直接执行</font>

```cpp
#include<myhead.h>
int main(int argc,const char* argv[])
{
    int num=0;
    int key;
    printf("请输入的值：");
    scanf("%d",&num);
    printf("num=%d\n",num);

    printf("请输入key的值：");
    scanf("%d",&key);
    printf("key=%d\n",key);
    return 0;
}
```

+ 使用直接输入1 2 的方式

![](https://cdn.nlark.com/yuque/0/2025/png/40383045/1746026467974-ba0b2a71-ad24-4c7e-a828-a635ca51a20d.png)

+ 使用先输入1，再输入2的方式

![](https://cdn.nlark.com/yuque/0/2025/png/40383045/1746026512669-2a6dbab7-0635-4936-a043-5f9eb5b13c40.png)

<font style="color:rgb(51,51,51);">从上述例子中的</font>**<font style="color:#DF2A3F;">第二个输入可以看出，如果事件先于函数发生，当程序再执行到函数时，函数会直接运 行，不会阻塞了</font>**<font style="color:rgb(51,51,51);"> 。</font>

## 2、IO多路复用原理图
![](https://cdn.nlark.com/yuque/0/2025/png/40383045/1746106460960-71e7c5b5-ed0b-4da6-98e6-d18ff7e9adcb.png)

## 3、select函数
### 3.1、select的了解和模型
+ 注意：**<font style="color:#DF2A3F;">当该函数解除阻塞时，文件描述符集合中，就只剩下本次触发事件的文件描述符，其余的文</font>**

**<font style="color:#DF2A3F;">件描述符就被删除了</font>** 。

```cpp
       #include <sys/select.h>
       int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, 
struct timeval *timeout);
       功能：阻塞等待文件描述符集合中是否有事件产生，如果有事件产生，则解除阻塞
       参数1：文件描述符集合中，最大的文件描述符 加1
                  参数2、参数3、参数4：分别表示读集合、写集合、异常处理集合的起始地址
       由于对于写操作而言，我们也可以转换读操作，所以，只需要使用一个集合
就行
       对于不使用的集合而言，直接填NULL即可
       参数5：超时时间，如果填NULL表示永久等待，如果想要设置时间，需要定义一个如下结构体类型
的变量，并将地址传递进去
       struct timeval {
               long    tv_sec;         /* 秒数 */
               long    tv_usec;        /* 微秒 */
           };
       and
           struct timespec {
               long    tv_sec;         /* 秒数 */
               long    tv_nsec;        /* 纳秒 */
           };
       返回值：
       >0:成功返回解除本次阻塞的文件描述符的个数
       =0:表示设置的超时时间，时间已经到达，但是没有事件事件产生
       =-1：表示失败，置位错误码
       注意：当该函数解除阻塞时，文件描述符集合中，就只剩下本次触发事件的文件描述符，其余的文
件描述符就被删除了
       
//专门针对于文件描述符集合提供的函数
       void FD_CLR(int fd, fd_set *set);       //将fd文件描述符从容器set中删除
       int  FD_ISSET(int fd, fd_set *set);     //判断fd文件描述符，是否存在于set容器
中
       void FD_SET(int fd, fd_set *set);      //将fd文件描述符，放入到set容器中
       void FD_ZERO(fd_set *set); //清空set容器
```

```cpp
sfd = socket();        //创建用于连接的套接字文件描述符
bind();                //绑定ip和端口号
listen();               //监听
fd_set  readfds, tempfds;    //定义文件描述符集合
FD_ZERO();        //清空容器
FD_SET();         //将文件描述符放入容器
maxfd = sfd;         //记录最大的文件描述符
while(1)
{
     tempfds = readfds;      //备份一份容器
     select(maxfd, &readfds, NULL, NULL, NULL);     //阻塞等待集合中是否有事件产生
 
 //判断相关文件描述符是否在集合中
 if(FD_ISSET(sfd, &tempfds))
 {
     newfd = accept();      //接收客户端请求
     FD_SET(newfd, &readfds);    //将新文件描述符放入集合
 //更新maxfd
 }
 
 //判断是否是客户端发来数据
 for(i=4; i<=maxfd; i++)
 {
     send();
     recv();
     close(i);     //退出客户端
     FD_CLR(i, &readfds);
 //更新maxfd
 }
 
}
//关闭监听
close(sfd);
```

### 3.2、实现select并发
```cpp
#include<myhead.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netinet/in.h>
#include<signal.h>
#include<sys/wait.h>
#include<pthread.h>
#include<sys/select.h>
#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.140.142"//服务器ip地址

int main(int argc,const char* argv[])
{
    
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    if(sfd==-1){
        perror("socket error");
        return -1;
    }
    printf("socket success sfd = %d\n",sfd);//3
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip
    sin.sin_port=htons(SER_PORT);//服务器端口号

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    int i =bind(sfd,(struct sockaddr*)&sin,sizeof(sin));
    if(i ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度
    
    //定义文件描述符集合
    fd_set readfds,tempfds;//读文件描述符集合
    //将该文件描述符清空
    FD_ZERO(&readfds);
    //将0号文件描述符以及sfd文件描述符放入到集合中
    FD_SET(0,&readfds);
    FD_SET(sfd,&readfds);//sfd是socket创建的
    
    //定义一个变量，用于存储容器中的最大文件描述符
    int maxfd = sfd;
    int newfd = -1;//接收客户端连接请求后，创建的通信套接字文件描述符
    //定义一个地址信息结构体数组来存储客户端对应的地址信息
    struct sockaddr_in cin_arr[1024];
    while(1){
        //将readfds备份放入tempfds中
        tempfds = readfds;
        //调用阻塞函数，完成对文件描述符集合的管理工作
        int res = select(maxfd+1,&tempfds,NULL,NULL,NULL);
        if(res == -1){
            perror("select error");
            return -1;
        }else if(res == 0){
            printf("time out!!!\n");
            return -1;
        }
        /*
        程序执行到此，表示一定有其中至少一个文件描述符产生了事件，
        只需要判断哪个文件描述符还在集合中
        */
        
        //就说明该文件描述符产生了事件
        //表示sfd文件描述符触发了事件,准备就绪，开始处理
        if(FD_ISSET(sfd,&tempfds)){
            int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
            //参数1：服务器套接字文件描述符
            //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
            //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
            if(newfd == -1){
                perror("accept error");
                return -1;
            }
            printf("[%s:%d]:已经连接成功！！！\n",
                inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
            //将该客户端对应的套接字地址信息结构体放入数组对应的位置上
            cin_arr[newfd]=cin;//newfd文件描述符对应的地址信息结构体
            //将当前的newfd放入到检测文件描述符集合中，以便于检测使用
            FD_SET(newfd,&readfds);//加入到tempfds
            //更新maxfd，如何更新？
            if(maxfd<newfd)//更新最大文件描述符
            {
                maxfd = newfd;
            }
        }
        //判断0号文件描述符是否产生了事件
        if(FD_ISSET(0,&tempfds)){
            char wbuf[128]="";//字符数组
            fgets(wbuf,sizeof(wbuf),stdin);//从终端读取数据，阻塞函数
            printf("触发了将输入输入事件：%s\n",wbuf);
            //能不能将输入的数据，全部发送给所有客户端

            for(int i =4;i<=maxfd;i++){
                send(i,wbuf,strlen(wbuf),0);//将数据发送给所有客户端
            }
        }
        //判断是否是newfd产生了事件
        /*循环所有客户端文件描述符遍历一遍，如果还存在于tempfds中的客户端，
        表示有数据接收过来*/
        for(int i = 4;i<=maxfd;i++){
            if(FD_ISSET(i,&tempfds))
            {
                //5、数据收发
                char rbuf[128]="";//数据容器
                //清空容器中的的内容
                bzero(rbuf,sizeof(rbuf));
                //从套接字中读取消息
                int res = recv(i,rbuf,sizeof(rbuf),0);
                if(res==0){
                    printf("对端已经下线\n");
                    close(i);
                    FD_CLR(i,&readfds);
                    //更新maxfd
                    for(int k = maxfd;k>=0;k--){
                        if(FD_ISSET(k,&readfds)){
                            maxfd = k;
                            break;//结束向下进行的循环
                        }
                    }
                    continue;
                }
                printf("[%s:%d]:%s\n",inet_ntoa(cin_arr[i].sin_addr),ntohs(cin_arr[i].sin_port),rbuf);
                //将处理后的客户端消息回显给该客户端
                strcat(rbuf,"*_*");
                if(send(i,rbuf,strlen(rbuf),0)==-1){
                    perror("send error");
                    return -1;
                }
                printf("发送成功!\n");
            }
        }
    }
    close(sfd);//关闭监听
    cout<<"hello world"<<endl;
    return 0;
}
           
```

## 4、poll函数
### 4.1、poll的了解
```cpp
       #include <poll.h>
       int poll(struct pollfd *fds, nfds_t nfds, int timeout);
       功能：阻塞等待文件描述符集合中是否有事件产生，如果有，则解除阻塞，返回本次触发事件的文件
描述符个数
       参数1：文件描述符集合容器的起始地址，是一个结构体数组，结构体类型如下
       struct pollfd {
               int   fd;         /* 文件描述符 */
               short events;     /* fd文件描述符要等待的事件：由用户填写 */
               short revents;    /* 实际发生的事件 ：调用函数结束后，内核会自动设置*/
           };
           关于事件对应的位：
           POLLIN:读事件
           POLLOUT：写事件
           
       参数2：集合中文件描述符的个数
       参数3：超时时间，负数表示永久等待，0表示非阻塞
       返回值：
       >0:表示触发本次解除阻塞事件的文件描述符的个数
       =0:表示超时
       =-1:出错，置位错误码
```



### 4.2、实现poll并发
客户端的实现，这里的端口号要换，才能实现并发，不能一个端口号连接2次。

```cpp
//客户端
#include<myhead.h>
#include<poll.h>
#include<arpa/inet.h>
#include<netinet/in.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<unistd.h>
#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.140.142"//服务器ip地址
#define CLI_IP   "192.168.140.142"
#define CLI_PORT 9999
int main(int argc,const char* argv[])
{
    //1、创建用于通信的客户端套接字文件描述符
    int cfd = socket(AF_INET,SOCK_STREAM,0);
    if(cfd == -1){
        perror("socket error");
        return -1;
    }
    //2、绑定服务器ip地址和端口号(可选)
    struct sockaddr_in cin;
    cin.sin_family = AF_INET;
    cin.sin_port = htons(CLI_PORT);//服务器
    cin.sin_addr.s_addr = inet_addr(CLI_IP);//服务器
    if(bind(cfd,(struct sockaddr*)&cin,sizeof(cin))==-1){
        perror("bind error");
        return -1;
    }
    printf("bind success\n");
    //3、连接服务器
    // 3.1、 定义地址信息结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_port = htons(SER_PORT);
    sin.sin_addr.s_addr = inet_addr(SER_IP);
    //3.2、连接工作
    if(connect(cfd,(struct sockaddr*)&sin,sizeof(sin))==-1){
        perror("connect error");
        return -1;
    }
    printf("连接服务器成功\n");
    //----------------------------------------------------------
    struct pollfd pfds[2];//pfs[0] pfds[1]
    pfds[0].fd = 0;         //表示0号文件描述符
    pfds[0].events = POLLIN;//表示检查的是读事件
    
    pfds[1].fd = cfd;       //表示cfd文件描述符
    pfds[1].events = POLLIN;//表示检查的是读事件
    
    
    //4、数据收发
    char wbuf[128]="";
    char rbuf[128] = "";  // 独立的接收缓冲区
    
    while(1){
        int res = poll(pfds,2,-1);
        //功能：阻塞等待文件描述符集合中是否有事件产生
        //参数1：文件描述符集合起始地址
        //参数2：文件描述符个数
        //参数3：表示永久等待
        if(res == -1){
            perror("poll error");
            return -1;
        }
        //程序执行至此，表示文件描述符容器中，有事件产生
        //表示0号文件描述符的事件
        if(pfds[0].revents&POLLIN){
            //清空容器
            memset(&wbuf, 0, sizeof(wbuf));
            //从终端获取数据
            if(fgets(wbuf, sizeof(wbuf), stdin) == NULL){  // 修改4：增加错误检查
                perror("fgets error");
                continue;
            }
            wbuf[strcspn(wbuf, "\n")] = '\0';
            if(send(cfd,wbuf,sizeof(wbuf)-1,0)==-1){
                perror("send error");
                break;
            }
            // 检查退出命令
            if (strcmp(wbuf, "quit") == 0) {
                printf("客户端退出\n");
                break;
            }
        }
        // 6. 处理标准输入事件(用户输入)
        
            //表示客户端发来消息
        if(pfds[1].revents&POLLIN){
            //接收服务器发送过来的消息
            if(recv(cfd,rbuf,sizeof(rbuf),0)==0){
                printf("对端已经下线\n");
                break;
            }
            printf("收到服务器消息为：%s\n",rbuf);
        }
        // 8. 处理错误事件
        if (pfds[1].revents & (POLLERR | POLLHUP | POLLNVAL)) {
            printf("Connection error occurred\n");
            break;
        }
    }


    //5、关闭套接字
    close(cfd);
    return 0;
}
```

## 5、select和poll的差异
+ 1、select管理三个文件描述符集合，poll只管理一个，但是，<font style="color:#DF2A3F;">可以操作很多事件</font>
+ 2、select管理的文件描述符有上限，<font style="color:#DF2A3F;">一般是1024个</font>，而<font style="color:#DF2A3F;">poll管理文件描述符没有这个限制</font>
+ 3、对于效率而言，<font style="color:#DF2A3F;">poll的效率比select的略高</font>

## 6、epoll函数
### 6.1、epoll的了解和模型
+ <font style="color:rgb(51,51,51);">epoll全称为eventpoll，是内核实现IO多路复用的一种实现方式。</font>**<font style="color:#DF2A3F;">在其中一个或多个事件的到满足 时，可以解除阻塞</font>**<font style="color:rgb(51,51,51);">。</font>
+ <font style="color:rgb(51,51,51);">epoll是select和poll的升级版，相比于select和poll而言，epoll改进了工作方式，效率更高。</font>

```cpp
       #include <sys/epoll.h>
       int epoll_create(int size);
       功能：创建一个epoll实例，并返回该实例的句柄，是一个文件描述符
       参数1：epoll实例中能够容纳的最大节点个数，自从linux 2.6.8版本后，size可以忽略，但是
必须要是一个大于0的数字
       返回值：成功返回控制epoll实例的文件描述符，失败返回-1并置位错误码
       
       
       #include <sys/epoll.h>
       int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
       功能：完成对epoll实例的控制
       参数1：通过epoll_create创建的epoll实例文件描述符
       参数2：op表示要进行的操作
        EPOLL_CTL_ADD：向epoll树上添加新的要检测的文件描述符
        EPOLL_CTL_MOD：改变epoll树上的文件描述符检测的事件
  EPOLL_CTL_DEL：删除epoll树上的要检测的文件描述符,此时参数3可以省略填NULL
 参数3：要检测的文件描述符
 参数4：要检测的事件，是一个结构体变量地址，属于输入变量
 
  typedef union epoll_data {
               void        *ptr;        //提供的解释性数据
               int          fd;       //文件描述符（常用）
               uint32_t     u32;
               uint64_t     u64;
           } epoll_data_t;
           struct epoll_event {
               uint32_t     events;      /* 要检测的事件 */
               epoll_data_t data;        /* 用户有效数据，是一个共用体 */
           };
           要检测的事件：
           EPOLLIN：读事件
           EPOLLOUT：写事件
           EPOLLERR：异常事件
           EPOLLET：表示设置epoll的模式为边沿触发模式
        
        
               #include <sys/epoll.h>
       int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int 
timeout);
       功能：阻塞检测epoll实例中是否有文件描述符准备就绪，如果准备就绪了，就解除阻塞
       参数1：epoll实例对于的文件描述符
       参数2：文件描述符集合，当有文件描述符产生事件时，将所有产生事件的文件描述符，
           放入到该集合中
       参数3：参数2的大小
       参数4：超时时间，以毫秒为单位的超时时间，如果填-1表示永久阻塞
       返回值：>0:表示解除本次操作的触发的文件描述符个数
       =0：表示超时，但是没有文件描述符产生事件
       =-1：失败，置位错误码
```

```cpp
1、sfd = scoket（）；//创建用于连接的文件描述符
2、bind（）；//绑定ip地址和端口号
3、isten（）；//将套接字设置成被动监听状态
    
4、创建一个epoll实例，并将用于连接的文件描述符放入到epoll树中
    struct epll_event ev;
ev.events = EPOLLIN;//检查读事件
ev.data.fd = sfd；//要检查的文件描述符
    int ret = eoll_ctl(epfd,evs,size,-1);
5、检查文件描述符是否就绪（有客户端发来连接请求）
    int num = epoll_wait(epfd,evs,size,-1);
6、如果检测到文件描述符就绪，则建立连接，将newfd放入到集合中
 newfd = accept();       //接收客户端连接请求
 struct epoll_event ev;
 ev.event = EPOLLIN;
 ev.data.fd = newfd;
 int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, newfd, &ev);
 
7、如果检测的是客户端文件描述符，则进行通信，如果客户端下线，则将文件描述符进行删除
 int len = recv();
 if(len == 0)
 {
     epoll_ctl(epfd, EPOLL_CTL_DEL, newfd, NULL);   //将newfd从集合中删除
     close(newfd);
 }else if(len > 0)
 {
     send();
 }
```

### 6.2、实现epoll并发
<font style="color:rgb(51,51,51);">epoll实现一个TCP数据处理服务器</font>

```cpp
//客户端
#include<myhead.h>
#include<poll.h>
#include<arpa/inet.h>
#include<netinet/in.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<unistd.h>
#include<sys/epoll.h>

#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.140.142"//服务器ip地址
int main(int argc,const char* argv[])
{
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_port=htons(SER_PORT);//服务器端口号
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    if(bind(sfd,(struct sockaddr*)&sin,sizeof(sin)) ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度


    //创建epoll实例，用于检查文件描述符--------------------------
    int epfd = epoll_create(1);
    if(epfd==-1){
        perror("epoll_create error");
        return -1;
    }
    //将sfd放入到检查集合中
    struct epoll_event ev;
    ev.events = EPOLLIN;//要检查的是读事件
    ev.data.fd = sfd; //要检测的文件描述符
    epoll_ctl(epfd,EPOLL_CTL_ADD,sfd,&ev);//添加sfd，内容是ev
    //功能将sfd放入到检测集合中
    //参数1：epol实例的文件描述符
    //参数2：epll操作，表示要添加文件描述符
    //参数3：要检测的文件描述符
    //参数4：要检测的事件

    //定义接收 返回的 事件集合
    struct epoll_event evs[1024];
    int size = sizeof(evs)/sizeof(evs[0]);//数组的大小

    while(1){
        //阻塞检测文件描述符集合中是否有事件产生
        int num = epoll_wait(epfd,evs,size,-1);
        //参数1：epoll实例的文件描述符
        //参数2：返回触发事件的文件事件集合
        //参数3：集合的大小
        //参数4：是否阻塞
        printf("num = %d\n",num);//输出本次触发的文件描述符个数
        //循环遍历集合
        for(int i = 0;i<num;i++){
            int fd = evs[i].data.fd;//获取本次解除阻塞的文件描述符
            //判断是否为sfd文件描述符就绪
            if(fd==sfd){
                int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
                //参数1：服务器套接字文件描述符
                //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
                //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
                if(newfd == -1){
                    perror("accept error");
                    return -1;
                }
                printf("[%s:%d]:已经连接成功！！！\n",
                    inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
                //将客户端文件文件描述符放入到epll检测集合中
                struct epoll_event ev;
                ev.events = EPOLLIN;//要检测的是读事件
                ev.data.fd = newfd;//要检测的文件描述符信息
                epoll_ctl(epfd,EPOLL_CTL_ADD,newfd,&ev);
                
            }else{
                //表示客户端文件描述符就绪，也就是说客户端有数据发来
                //5、数据收发
                char rbuf[128]="";//数据容器
                //清空容器
                bzero(rbuf,sizeof(rbuf));
                //从套接字中读取消息
                int res = recv(fd,rbuf,sizeof(rbuf),0);
                if(res ==0 ){
                    printf("对端已经下线\n");
                    //将客户端从epoll树中删除
                    epoll_ctl(epfd,EPOLL_CTL_DEL,fd,NULL);
                    
                    close(fd);
                    break;
                }
                printf("收到的数据：%s\n",rbuf);
                //对收到的数据随便处理一下，回给客户端
                strcat(rbuf,"*_*");
                //将消息发送给客户端
                if(send(fd,rbuf,strlen(rbuf)-1,0)==-1){
                    perror("send error");
                    return -1;
                }
                printf("发送成功\n");
            }
        }
    }
    //6、关闭套接字
    
    close(sfd); //关闭监听
    close(epfd);//关闭epoll实例
    cout<<"hello world"<<endl;
    return 0;
}

```

## 7、epoll、select、poll的差异
+ <font style="color:rgb(17,102,68);">1</font><font style="color:rgb(0,0,0);">、</font><font style="color:#DF2A3F;">sellect和poll都是基于线性结构</font><font style="color:rgb(0,0,0);">进行检测集合，而</font><font style="color:#DF2A3F;">epoll是基于树形结构（红黑树）完成管理检测集合 </font><font style="color:rgb(0,0,0);">的 。</font>
+ <font style="color:rgb(17,102,68);">2</font><font style="color:rgb(0,0,0);">、select和poll检测时，</font><font style="color:#DF2A3F;">随着集合的增大，效率会越来越低</font><font style="color:rgb(0,0,0);">。epoll使用的是函数回调机制，效率较高。 </font><font style="color:#DF2A3F;">处理文件描述符的效率也不会随着文件秒数的增大而降低</font><font style="color:rgb(0,0,0);">。 </font>
+ <font style="color:rgb(17,102,68);">3</font><font style="color:rgb(0,0,0);">、select和poll在工作过程中，</font>**<font style="color:#DF2A3F;">不断的在内核空间与用户空间频繁拷贝文件描述符的数据</font>**<font style="color:rgb(0,0,0);">。epoll在注册 </font><font style="color:#DF2A3F;">新的文件描述符或者修改文件描述符</font><font style="color:rgb(0,0,0);">时，</font>**<font style="color:#DF2A3F;">只需进行一次，能够有效减少数据在用户空间和内核空间之间的切换 。</font>**
+ <font style="color:rgb(17,102,68);">4</font><font style="color:rgb(0,0,0);">、和poll一样，</font><font style="color:#DF2A3F;">epoll没有最大文件描述符的限制</font><font style="color:rgb(0,0,0);">，仅仅收到程序能够打开的最大文件描述符数量限制 。</font>
+ <font style="color:rgb(17,102,68);">5</font><font style="color:rgb(0,0,0);">、对于select和poll而言，需要对返回的文件描述符集合进行判断后才知道时哪些文件描述符就绪了，而 epoll可以直接得到已经就绪的文件描述符，</font>**<font style="color:#DF2A3F;">无需再次检测</font>**<font style="color:rgb(0,0,0);"> 。</font>
+ <font style="color:rgb(17,102,68);">6</font><font style="color:rgb(0,0,0);">、当多路复用</font><font style="color:#DF2A3F;">比较频发进行、IO流量频繁的时候</font><font style="color:rgb(0,0,0);">，一般不使用select和poll，</font>**<font style="color:#DF2A3F;">使用epoll</font>**<font style="color:rgb(0,0,0);">比较合适 。</font>
+ <font style="color:rgb(17,102,68);">7</font><font style="color:rgb(0,0,0);">、</font><font style="color:#DF2A3F;">epoll只适用于linux平台</font><font style="color:rgb(0,0,0);">，不能跨平台操作。</font>

## <font style="color:rgb(0,0,0);">8、epoll的工作模式：水平触发和边沿触发</font>
![](https://cdn.nlark.com/yuque/0/2025/png/40383045/1746176716847-34c534a8-1adc-4c74-be17-061ba44bcfd9.png)

## 8.1、水平触发模式level trigered
<font style="color:rgb(17,102,68);">1</font><font style="color:rgb(0,0,0);">、水平模式： 简称LT模式（leveltrigered）</font><font style="color:rgb(51,51,51);">,</font><font style="color:rgb(0,0,0);">是</font>**<font style="color:#DF2A3F;">默认初始模式</font>**<font style="color:rgb(0,0,0);">，并且该模式</font>**<font style="color:#DF2A3F;">支持阻塞和非阻塞</font>**<font style="color:rgb(0,0,0);">的形式 </font>

<font style="color:rgb(0,0,0);">在这种模式下，当</font>**<font style="color:#DF2A3F;">文件描述符准备就绪后</font>**<font style="color:rgb(0,0,0);">，</font>**<font style="color:#DF2A3F;">内核会</font>****<font style="color:#DF2A3F;background-color:#FBDE28;">重复通知</font>****<font style="color:#DF2A3F;">使用者哪些文件描述符就绪了</font>**<font style="color:rgb(0,0,0);">。 </font>

**<font style="color:#DF2A3F;">使用者</font>**<font style="color:rgb(0,0,0);">可以</font>**<font style="color:#DF2A3F;">对就绪的文件描述符进行操作</font>**<font style="color:rgb(0,0,0);">。</font>

<font style="color:rgb(0,0,0);"> 如果</font>**<font style="color:#DF2A3F;">使用者不做任何操作或者没有全部处理完该文件描述符的信息</font>**<font style="color:rgb(0,0,0);">，</font>**<font style="color:#DF2A3F;">内核会</font>****<font style="color:#DF2A3F;background-color:#FBDE28;">继续通知</font>****<font style="color:#DF2A3F;">使用者处理数据 </font>**

+ **<font style="color:#DF2A3F;">特点</font>**<font style="color:rgb(0,0,0);">： </font>
    - <font style="color:rgb(0,0,0);">对于读事件：如果该文件描述符中的缓冲区中的数据没有被读取完毕，则内核</font><font style="color:#DF2A3F;">会继续解除阻塞</font><font style="color:rgb(0,0,0);">，</font><font style="color:#DF2A3F;">让 用户继续处理</font><font style="color:rgb(0,0,0);">，直到缓冲区中没有数据可以处理为止。 </font>
        * <font style="color:rgb(0,0,0);">后面的</font><font style="color:#DF2A3F;">解除阻塞，是自动完成的</font><font style="color:rgb(0,0,0);">，无需用户进行对文件描述符的后续操作。</font>
    - <font style="color:rgb(0,0,0);">对于写事件：检测文件描述符缓冲区是否可以，如果可用则解除阻塞，一般写文件描述符的缓冲区 都是可以的，一般不对写文件描述符进行检测 </font>

![](https://cdn.nlark.com/yuque/0/2025/png/40383045/1746178032862-6a4a5107-97eb-4754-95a2-b3d5724ef12e.png)

<font style="color:rgb(24, 25, 28);">客户端一下子发送Welcome to NetAssist*_*</font>

<font style="color:rgb(24, 25, 28);">但是服务端一下子发出来的是 一截一截的。</font>

### 8.2、边沿触发模式
<font style="color:rgb(17,102,68);">2</font><font style="color:rgb(0,0,0);">、边沿模式 </font>

<font style="color:rgb(0,0,0);">简称ET模式（edgetrigered）</font><font style="color:rgb(51,51,51);">,</font><font style="color:rgb(0,0,0);">需要</font>**<font style="color:#DF2A3F;">手动设置</font>**<font style="color:rgb(0,0,0);">该模式，并且该模式一般</font>**<font style="color:#DF2A3F;">支持非阻塞</font>**<font style="color:rgb(0,0,0);">形式 </font>

<font style="color:rgb(0,0,0);">在种模式下，当文件描述符准备就绪后，内核会通知使用者哪些文件描述符就绪了，但是</font>**<font style="color:#DF2A3F;">仅仅只通知一次 </font>**<font style="color:rgb(0,0,0);">。</font>

<font style="color:#DF2A3F;">使用者可以对就绪的文件描述符进行操作</font><font style="color:rgb(0,0,0);"> </font>

<font style="color:#DF2A3F;">如果使用者不做任何操作</font><font style="color:rgb(0,0,0);">，或者没有全部处理该文件描述符的信息，内核</font><font style="color:#DF2A3F;">不会通知</font><font style="color:rgb(0,0,0);">使用者</font>**<font style="color:#DF2A3F;">再次处理</font>**<font style="color:rgb(0,0,0);">数据， </font><font style="color:#DF2A3F;">直到下一次该文件描述符的事件产生</font><font style="color:rgb(0,0,0);"> </font>

<font style="color:rgb(0,0,0);">特点：</font>

<font style="color:rgb(0,0,0);">对于读事件：如果文件描述符中的缓冲区数据没有读取完毕，则内核也</font>**<font style="color:#DF2A3F;">不会再次解除阻塞</font>**<font style="color:rgb(0,0,0);">，直到下 一次的该文件描述符事件产生，</font>**<font style="color:#DF2A3F;">但是下一次的文件描述符的事件，读取的是上一次没有读取完毕的内容 </font>**

<font style="color:rgb(0,0,0);">对于写事件：检测文件描述符缓冲区是否可以，如果可用则解除阻塞，一般写文件描述符的缓冲区 都是可以的，一般不对写文件描述符进行检测 </font><font style="color:rgb(51,51,51);">    </font>

**<font style="color:#DF2A3F;">边沿触发模式的处理效率会更高一些</font>**<font style="color:rgb(0,0,0);">，</font>**<font style="color:#DF2A3F;">要求用户必须一次性处理文件描述符中的数据</font>**<font style="color:rgb(0,0,0);"> </font><font style="color:rgb(51,51,51);">     </font>

<font style="color:rgb(17,102,68);">3</font><font style="color:rgb(0,0,0);">、如何设置边沿触发：在将文件描述符放入到epoll树中时，需要加一个属性 </font><font style="color:rgb(51,51,51);">   </font>

<font style="color:rgb(119,0,136);">struct </font><font style="color:rgb(0,0,255);">epoll_eventev</font><font style="color:rgb(51,51,51);">; </font>

<font style="color:rgb(0,0,0);">ev</font><font style="color:rgb(51,51,51);">.</font><font style="color:rgb(0,0,0);">event</font><font style="color:rgb(152,26,26);">=</font><font style="color:rgb(0,0,0);">EPOLLIN</font><font style="color:rgb(152,26,26);">|</font><font style="color:rgb(0,0,0);">EPOLLEV</font><font style="color:rgb(51,51,51);">;</font>

```cpp
//客户端
#include<myhead.h>
#include<poll.h>
#include<arpa/inet.h>
#include<netinet/in.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<unistd.h>
#include<sys/epoll.h>

#define SER_PORT 8080 //服务器端口号
#define SER_IP "192.168.140.142"//服务器ip地址
int main(int argc,const char* argv[])
{
    //1、创建用于连接的套接字文件描述符
    int sfd = socket(AF_INET,SOCK_STREAM,0);
    //参数1：使用的ip类型
    //参数2：使用的tcp
    //参数3：参数2指定了协议
    //2、绑定ip地址和端口号
    //2.1、填充要绑定的ip地址和端口号结构体
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;//通信域
    sin.sin_port=htons(SER_PORT);//服务器端口号
    sin.sin_addr.s_addr=inet_addr(SER_IP);//服务器ip

    //2.2、绑定工作
    //参数1：要被绑定的套接字文件描述符
    //参数2：要绑定的地址信息结构体，需要进行强制类型转换，防止警告
    //参数3：参数2的大小
    if(bind(sfd,(struct sockaddr*)&sin,sizeof(sin)) ==-1){
        perror("socket error");
        return -1;
    }
    printf("bind success\n");
    //3、启动监听
    if(listen(sfd,128)==-1){
        perror("listen error");
        return -1;
    }
    printf("listen success\n");

    //参数1：要启动监听的文件描述符
    //参数2：挂起队列的长度

    //4、阻塞等待客户端的连接请求
    //定义变量，用于接受客户端地址信息结构体
    struct sockaddr_in cin;    //用于接收地址信息结构体的
    socklen_t socklen = sizeof(cin);    //用于接收地址信息的长度


    //创建epoll实例，用于检查文件描述符--------------------------
    int epfd = epoll_create(1);
    if(epfd==-1){
        perror("epoll_create error");
        return -1;
    }
    //将sfd放入到检查集合中
    struct epoll_event ev;
    
    ev.events = EPOLLIN| EPOLLET;//要检查的是读事件=============
    //使用边沿



    ev.data.fd = sfd; //要检测的文件描述符
    epoll_ctl(epfd,EPOLL_CTL_ADD,sfd,&ev);//添加sfd，内容是ev
    //功能将sfd放入到检测集合中
    //参数1：epol实例的文件描述符
    //参数2：epll操作，表示要添加文件描述符
    //参数3：要检测的文件描述符
    //参数4：要检测的事件

    //定义接收 返回的 事件集合
    struct epoll_event evs[1024];
    int size = sizeof(evs)/sizeof(evs[0]);//数组的大小

    while(1){
        //阻塞检测文件描述符集合中是否有事件产生
        int num = epoll_wait(epfd,evs,size,-1);
        //参数1：epoll实例的文件描述符
        //参数2：返回触发事件的文件事件集合
        //参数3：集合的大小
        //参数4：是否阻塞
        printf("num = %d\n",num);//输出本次触发的文件描述符个数
        //循环遍历集合
        for(int i = 0;i<num;i++){
            int fd = evs[i].data.fd;//获取本次解除阻塞的文件描述符
            //判断是否为sfd文件描述符就绪
            if(fd==sfd){
                int newfd = accept(sfd,(struct sockaddr*)&cin,&socklen);
                //参数1：服务器套接字文件描述符
                //参数2：用于接收客户端地址信息结构体的容器，如果不接收，也可以填NULL
                //参数3：接收参数2的大小，如果参数2为NULL，则参数3也是NULL
                if(newfd == -1){
                    perror("accept error");
                    return -1;
                }
                printf("[%s:%d]:已经连接成功！！！\n",
                    inet_ntoa(cin.sin_addr),ntohs(cin.sin_port));
                //将客户端文件文件描述符放入到epll检测集合中
                struct epoll_event ev;
                
                
                ev.events = EPOLLIN|EPOLLET;//要检测的是读事件==========


                ev.data.fd = newfd;//要检测的文件描述符信息
                epoll_ctl(epfd,EPOLL_CTL_ADD,newfd,&ev);
                
            }else{
                //表示客户端文件描述符就绪，也就是说客户端有数据发来
                //5、数据收发
                char rbuf[5]="";
                
                
                //数据容器=========这里设置成5，LT模式
                
                
                
                
                //清空容器
                bzero(rbuf,sizeof(rbuf));
                //从套接字中读取消息
                int res = recv(fd,rbuf,sizeof(rbuf),0);
                if(res ==0 ){
                    printf("对端已经下线\n");
                    //将客户端从epoll树中删除
                    epoll_ctl(epfd,EPOLL_CTL_DEL,fd,NULL);
                    
                    close(fd);
                    break;
                }
                printf("收到的数据：%s\n",rbuf);
                //对收到的数据随便处理一下，回给客户端
                strcat(rbuf,"*_*");
                //将消息发送给客户端
                if(send(fd,rbuf,strlen(rbuf)-1,0)==-1){
                    perror("send error");
                    return -1;
                }
                printf("发送成功\n");
            }
        }
    }
    //6、关闭套接字
    
    close(sfd); //关闭监听
    close(epfd);//关闭epoll实例
    cout<<"hello world"<<endl;
    return 0;
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/40383045/1746178380367-baf625ac-de33-42fe-b10e-f34e96424cd7.png)

客户端发一次，服务端接收 5个 ，客户端再次发一次，服务端接收上一次客户端发的信息剩下部分。

### <font style="color:rgb(24, 25, 28);">8.3、select和poll，epoll的模式区别</font>
select、poll只有水平触发

epoll默认水平触发，可设置边缘触发

